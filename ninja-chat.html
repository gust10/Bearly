<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Study Ninja</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      height: 100%;
      font-family: 'SF Pro Rounded', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: transparent;
    }

    .chat-window {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 16px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      -webkit-app-region: drag;
      border-bottom: 1px solid #f0f0f0;
    }

    .chat-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chat-avatar {
      width: 28px;
      height: 28px;
      background: url('mov/cover.png') no-repeat center center;
      background-size: cover;
      border-radius: 50%;
      position: relative;
    }

    .chat-title {
      font-size: 13px;
      font-weight: 700;
      color: #4a4a5a;
    }

    .chat-subtitle {
      font-size: 10px;
      color: #c4b5fd;
    }

    .chat-close {
      -webkit-app-region: no-drag;
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .chat-close:hover { background: #fee2e2; color: #f87171; }

    /* Transcript */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .msg {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 14px;
      font-size: 13px;
      line-height: 1.5;
      animation: msg-in 0.2s ease-out;
    }

    @keyframes msg-in {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .msg.ninja {
      background: linear-gradient(135deg, #faf5ff, #fce7f3);
      color: #4a4a5a;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }

    .msg.user {
      background: linear-gradient(135deg, #e8a0bf, #c4b5fd);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }

    /* Voice controls */
    .voice-area {
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      border-top: 1px solid #f0f0f0;
    }

    .status-text {
      font-size: 12px;
      color: #999;
    }

    .status-text.active { color: #8b5cf6; }

    .mic-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #e8a0bf, #c4b5fd);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      position: relative;
    }

    .mic-btn:hover { transform: scale(1.05); }

    .mic-btn.listening {
      animation: pulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 0 0 rgba(196, 181, 253, 0.4);
    }

    .mic-btn.speaking {
      background: linear-gradient(135deg, #86efac, #34d399);
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(196, 181, 253, 0.4); }
      70% { box-shadow: 0 0 0 15px rgba(196, 181, 253, 0); }
      100% { box-shadow: 0 0 0 0 rgba(196, 181, 253, 0); }
    }

    .mic-btn.disconnected {
      background: #e8e8e8;
      color: #999;
    }

    .end-btn {
      padding: 6px 16px;
      border: 1px solid #e8e8e8;
      border-radius: 8px;
      background: white;
      color: #999;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .end-btn:hover { border-color: #f87171; color: #f87171; }

    .connecting-text {
      font-size: 12px;
      color: #c4b5fd;
    }
  </style>
</head>
<body>
  <div class="chat-window">
    <div class="chat-header">
      <div class="chat-header-left">
        <div class="chat-avatar"></div>
        <div class="chat-header-info">
          <div class="chat-title">Bearly</div>
          <div class="chat-subtitle" id="statusLabel">Your AI Study Bear</div>
        </div>
      </div>
      <button class="chat-close" id="chatClose">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </div>

    <div class="chat-messages" id="chatMessages"></div>

    <div class="voice-area">
      <div class="status-text" id="modeText">Connecting...</div>
      <button class="mic-btn disconnected" id="micBtn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
      </button>
      <button class="end-btn" id="endBtn">End conversation</button>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    const { Conversation } = require('@elevenlabs/client');

    const chatMessages = document.getElementById('chatMessages');
    const micBtn = document.getElementById('micBtn');
    const modeText = document.getElementById('modeText');
    const statusLabel = document.getElementById('statusLabel');

    let conversation = null;
    let conversationTranscript = [];
    let autoCloseTimer = null;
    let shouldAutoClose = false;

    const GOODBYE_PHRASES = [
      'bye', 'goodbye', 'see you', 'see ya', 'later', 'good luck',
      'happy studying', 'get to it', 'go study', 'go get', 'have fun',
      'talk soon', 'catch you', 'take care'
    ];

    async function doClose() {
      await saveTranscript();
      if (conversation) {
        await conversation.endSession();
        conversation = null;
      }
      ipcRenderer.send('ninja-talking-state', 'idle');
      ipcRenderer.send('close-ninja-chat');
    }

    function scheduleAutoClose(delay = 3000) {
      if (autoCloseTimer) clearTimeout(autoCloseTimer);
      autoCloseTimer = setTimeout(() => {
        autoCloseTimer = null;
        if (micBtn.classList.contains('speaking')) {
          // Agent is mid-speech — defer close until it finishes
          shouldAutoClose = true;
        } else {
          doClose();
        }
      }, delay);
    }

    function checkForGoodbye(text) {
      const lower = text.toLowerCase();
      return GOODBYE_PHRASES.some(phrase => lower.includes(phrase));
    }

    function addMessage(text, sender) {
      // Check if last message is same sender — update it instead
      const last = chatMessages.lastElementChild;
      if (last && last.classList.contains(sender) && last.dataset.final !== 'true') {
        last.textContent = text;
      } else {
        const msg = document.createElement('div');
        msg.className = 'msg ' + sender;
        msg.textContent = text;
        chatMessages.appendChild(msg);
      }
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function finalizeLastMessage(sender) {
      const last = chatMessages.lastElementChild;
      if (last && last.classList.contains(sender)) {
        last.dataset.final = 'true';
      }
    }

    async function saveTranscript() {
      if (conversationTranscript.length > 0) {
        ipcRenderer.send('save-conversation-transcript', conversationTranscript.join('\n'));
        conversationTranscript = [];
      }
    }

    async function startConversation() {
      try {
        const signedUrl = await ipcRenderer.invoke('get-signed-url');
        console.log('[Voice] Got signed URL:', signedUrl ? 'yes' : 'no');
        const memoryContext = await ipcRenderer.invoke('get-learning-profile');
        console.log('[Voice] Memory context length:', memoryContext ? memoryContext.length : 0);

        conversation = await Conversation.startSession({
          signedUrl,
          connectionType: 'websocket',
          overrides: memoryContext ? {
            agent: {
              prompt: {
                prompt: `You are a cute, friendly study bear assistant. You speak in a casual, encouraging way. Keep responses short (2-3 sentences max).\n\nYour conversation flow should ALWAYS follow these steps:\n1. First, ask how the student is feeling about studying today (energy level).\n2. Then ask: "What do you need to work on today?" or "What subjects or tasks do you need to study?"\n3. Listen to their answer. Ask follow-up questions if needed to understand their tasks clearly.\n4. Based on their energy level, create a todo list of 2-5 study tasks with time estimates:\n   - Low energy / tired = shorter tasks (10-15 min each)\n   - Medium / okay = normal tasks (20-25 min each)\n   - High focus / energized = longer tasks (30-50 min each)\n5. Read the task list back to them briefly, then call set_study_tasks with the list.\n6. After setting tasks, call start_pomodoro to begin the first task.\n7. Say something encouraging and say goodbye.\n\nIMPORTANT: You MUST always ask what they need to study and create a task list using set_study_tasks before starting the pomodoro. Never skip the task list step.\n\nYou have access to client tools: set_study_tasks, start_pomodoro, stop_pomodoro, add_exam, start_quiz.\n\nStudent Memory (use this to personalize your responses):\n${memoryContext}`
              }
            }
          } : undefined,

          clientTools: {
            set_study_tasks: async (params) => {
              ipcRenderer.send('voice-set-study-tasks', params.tasks || []);
              return "Study plan set! Opening your planner.";
            },
            start_pomodoro: async (params) => {
              ipcRenderer.send('voice-start-pomodoro', {
                duration: params.duration || 25,
                breakDuration: params.break_duration || 5,
                reps: params.reps || 4
              });
              scheduleAutoClose(4000);
              return "Pomodoro timer started!";
            },
            stop_pomodoro: async () => {
              ipcRenderer.send('voice-stop-pomodoro');
              return "Timer stopped.";
            },
            add_exam: async (params) => {
              ipcRenderer.send('voice-add-exam', {
                subject: params.subject,
                date: params.date
              });
              return `Exam for ${params.subject} added!`;
            },
            start_quiz: async () => {
              ipcRenderer.send('voice-start-quiz');
              scheduleAutoClose(4000);
              return "Starting a quiz!";
            }
          },

          onConnect: () => {
            console.log('[Voice] Connected successfully');
            statusLabel.textContent = 'voice chat';
            micBtn.classList.remove('disconnected');
            micBtn.classList.add('listening');
            modeText.textContent = 'Listening...';
            ipcRenderer.send('ninja-talking-state', 'listening');
          },

          onDisconnect: (reason) => {
            console.log('[Voice] Disconnected, reason:', reason);
            statusLabel.textContent = 'disconnected';
            micBtn.classList.add('disconnected');
            micBtn.classList.remove('listening', 'speaking');
            modeText.textContent = 'Disconnected';
            ipcRenderer.send('ninja-talking-state', 'idle');
          },

          onMessage: (message) => {
            if (message.source === 'user') {
              if (message.message) {
                addMessage(message.message, 'user');
                if (message.type === 'final') {
                  finalizeLastMessage('user');
                  conversationTranscript.push('Student: ' + message.message);
                }
              }
            } else if (message.source === 'ai') {
              if (message.message) {
                addMessage(message.message, 'ninja');
                if (message.type === 'final') {
                  finalizeLastMessage('ninja');
                  conversationTranscript.push('Ninja: ' + message.message);
                  if (checkForGoodbye(message.message)) {
                    scheduleAutoClose(3000);
                  }
                }
              }
            }
          },

          onModeChange: (mode) => {
            if (mode.mode === 'speaking') {
              micBtn.classList.remove('listening');
              micBtn.classList.add('speaking');
              modeText.textContent = 'Ninja is speaking...';
              ipcRenderer.send('ninja-talking-state', 'speaking');
            } else {
              micBtn.classList.remove('speaking');
              micBtn.classList.add('listening');
              modeText.textContent = 'Listening...';
              ipcRenderer.send('ninja-talking-state', 'listening');
              if (shouldAutoClose) {
                shouldAutoClose = false;
                doClose();
              }
            }
          },

          onError: (error) => {
            console.error('[Voice] Conversation error:', error, JSON.stringify(error));
            modeText.textContent = 'Error occurred';
          },
        });
      } catch (err) {
        console.error('Failed to start conversation:', err);
        modeText.textContent = 'Failed to connect';
        statusLabel.textContent = 'error';
      }
    }

    // End conversation
    document.getElementById('endBtn').addEventListener('click', () => doClose());
    document.getElementById('chatClose').addEventListener('click', () => doClose());

    // Quiz mode conversation
    async function startQuizConversation(questions) {
      try {
        const signedUrl = await ipcRenderer.invoke('get-signed-url');
        console.log('[Voice Quiz] Starting with', questions.length, 'questions');

        const questionsText = questions.map((q, i) =>
          `Q${i + 1}: "${q.question}" → Answer: "${q.answer}"`
        ).join('\n');

        conversation = await Conversation.startSession({
          signedUrl,
          connectionType: 'websocket',
          overrides: {
            agent: {
              prompt: {
                prompt: `You are a cute, friendly study bear quiz master. You speak in a casual, encouraging way. Keep responses short (2-3 sentences max).

You have the following quiz questions to ask the student. Ask them ONE AT A TIME:

${questionsText}

RULES:
1. Start by saying hi and that you have ${questions.length} questions ready.
2. Ask the first question clearly.
3. After the student answers, carefully compare their answer to the CORRECT ANSWER provided above.
4. If their answer is correct or mostly correct, praise them and confirm the key point.
5. If their answer is WRONG or INCOMPLETE:
   - Point out specifically what was wrong or missing in their answer.
   - Read out the correct answer so they learn it.
   - For example: "Not quite! You said X, but the correct answer is Y because..."
6. If their answer is partially correct, acknowledge what they got right, then fill in what they missed.
7. Then move to the next question.
8. After all questions are done, give a score (e.g. "You got 3 out of 5!"), congratulate them, and say goodbye.
9. Keep it fun and encouraging — use phrases like "nice job!", "almost!", "you got this!".
10. Do NOT read the answer before the student responds.
11. Do NOT ask all questions at once — one at a time only.
12. Always reference the specific correct answer when giving feedback — don't just say "that's wrong", explain what the right answer is.`
              }
            }
          },

          clientTools: {
            start_pomodoro: async (params) => {
              ipcRenderer.send('voice-start-pomodoro', {
                duration: params.duration || 25,
                breakDuration: params.break_duration || 5,
                reps: params.reps || 4
              });
              scheduleAutoClose(4000);
              return "Pomodoro timer started!";
            }
          },

          onConnect: () => {
            console.log('[Voice Quiz] Connected');
            statusLabel.textContent = 'quiz mode';
            micBtn.classList.remove('disconnected');
            micBtn.classList.add('listening');
            modeText.textContent = 'Listening...';
            ipcRenderer.send('ninja-talking-state', 'listening');
          },

          onDisconnect: (reason) => {
            console.log('[Voice Quiz] Disconnected:', reason);
            statusLabel.textContent = 'disconnected';
            micBtn.classList.add('disconnected');
            micBtn.classList.remove('listening', 'speaking');
            modeText.textContent = 'Disconnected';
            ipcRenderer.send('ninja-talking-state', 'idle');
          },

          onMessage: (message) => {
            if (message.source === 'user') {
              if (message.message) {
                addMessage(message.message, 'user');
                if (message.type === 'final') {
                  finalizeLastMessage('user');
                  conversationTranscript.push('Student: ' + message.message);
                }
              }
            } else if (message.source === 'ai') {
              if (message.message) {
                addMessage(message.message, 'ninja');
                if (message.type === 'final') {
                  finalizeLastMessage('ninja');
                  conversationTranscript.push('Bear: ' + message.message);
                  if (checkForGoodbye(message.message)) {
                    scheduleAutoClose(3000);
                  }
                }
              }
            }
          },

          onModeChange: (mode) => {
            if (mode.mode === 'speaking') {
              micBtn.classList.remove('listening');
              micBtn.classList.add('speaking');
              modeText.textContent = 'Bear is speaking...';
              ipcRenderer.send('ninja-talking-state', 'speaking');
            } else {
              micBtn.classList.remove('speaking');
              micBtn.classList.add('listening');
              modeText.textContent = 'Listening...';
              ipcRenderer.send('ninja-talking-state', 'listening');
              if (shouldAutoClose) {
                shouldAutoClose = false;
                doClose();
              }
            }
          },

          onError: (error) => {
            console.error('[Voice Quiz] Error:', error);
            modeText.textContent = 'Error occurred';
          },
        });
      } catch (err) {
        console.error('[Voice Quiz] Failed to start:', err);
        modeText.textContent = 'Failed to connect';
        statusLabel.textContent = 'error';
      }
    }

    // Start when greeting is received
    ipcRenderer.on('ninja-greeting', () => {
      startConversation();
    });

    // Start quiz mode when questions are received
    ipcRenderer.on('ninja-greeting-quiz', (_, questions) => {
      startQuizConversation(questions);
    });
  </script>
</body>
</html>
